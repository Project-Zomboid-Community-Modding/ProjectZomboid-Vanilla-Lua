---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by RJ.
--- DateTime: 8/20/2024 9:19 AM
---

ButcheringUtil = {};

-- add relevant moddata in the animal's IsoDeadBody
-- function called when creating an IsoDeadBody from an animal
-- this'll be mostly used by the butcher hook
function setAnimalBodyData(died, modData)
    modData["AnimalType"] = died:getAnimalType();
    modData["AnimalBreed"] = died:getBreed():getName();
    local fullName = modData["AnimalType"] .. modData["AnimalBreed"];

    -- setup all things that can be removed from this animal (this is used when doing the "remove parts" on the butcher table)
    local def = AnimalPartsDefinitions.animals[fullName];
    modData["parts"] = def ~= nil;

    --for i,v in pairs(def) do
    --    modData[i] = "true";
    --end

    modData["BloodQty"] = died:getBloodQuantity();

    if def.feather then
        modData["MaxFeather"] = died:getFeatherNumber();
    end

    if died:shouldBeSkeleton() then
        modData["skeleton"] = "true";
    end

    modData["leather"] = ButcheringUtil.getLeather(fullName) ~= nil;
    if (not AnimalAvatarDefinition[modData["AnimalType"]] or not AnimalAvatarDefinition[modData["AnimalType"]].hook) and ButcheringUtil.getLeather(fullName) then -- if the animal is a baby, we'll still give leather as he can't be put on the hook
        modData["babyLeather"] = true;
    end
    modData["head"] = ButcheringUtil.getHead(fullName) ~= nil;
    modData["meatRatio"] = died:getUsedGene("meatRatio"):getCurrentValue();
    modData["isbaby"] = died:isBaby();
    modData["corpseSize"] = died:getCorpseSize() * died:getAnimalOriginalSize();
    modData["animalSize"] = died:getAnimalOriginalSize();
    modData["corpseLength"] = died:getCorpseLength() * died:getAnimalSize(); -- TODO RJ: currently not working
    modData["animalTrailerSize"] = died:getAnimalTrailerSize();
    if died:getData():getPregnancyTime() / died:getData():getPregnantPeriod() > 0.3 then
        modData["wasPregnant"] = died:getData():isPregnant();
        modData["pregnancyTime"] = died:getData():getPregnancyTime() / died:getData():getPregnantPeriod();
        modData["babiesNbr"] = ZombRand(died:getAdef():getMinBaby(), died:getAdef():getMaxBaby());
    end
    if died:getData():getWoolQuantity() > 0 and died:getBreed():getWoolType() then
        modData["wool"] = died:getBreed():getWoolType();
        modData["woolQty"] = died:getData():getWoolQuantity();
        modData["shouldBeBodyFleece"] = died:getData():getWoolQuantity() > (died:getData():getMaxWool() / 2);
    end
    modData["roadKill"] = died:isRoadKill();
end

-- Give every items to the player defined in ButcheringUtil.animals[]
function ButcheringUtil.butcherAnimalFromGround(carcass, player, keepCorpse)
    if isClient() then return; end

    totalHunger = 0;
    totalLipids = 0;
    totalProteins = 0;
    totalCarbo = 0;
    totalCalories = 0;

    local text = "Animal size: " .. carcass:getAnimalSize() .. "\r\n";
    text = text .. "Meat ratio: " .. carcass:getModData()["meatRatio"] .. "\r\n";
    text = text .. "Butchering skill: " .. player:getPerkLevel(Perks.Butchering) .. "\r\n \r\n";

    local partDef = ButcheringUtil.getAnimalDef(ButcheringUtil.getCarcassName(carcass));
    if not partDef then
        log(DebugType.Animal, "Couldn't find animal part def for animal: " .. ButcheringUtil.getCarcassName(carcass));
        return;
    end

    local adef = AnimalDefinitions.getDef(carcass:getAnimalType());
    if adef == nil then
        log(DebugType.Animal, "Couldn't find animal def for animal type: " .. carcass:getAnimalType());
        return;
    end

    local breed = adef:getBreedByName(carcass:getBreed());
    if breed == nil then
        log(DebugType.Animal, "Couldn't find animal breed def for breed type: " .. carcass:getBreed());
        return;
    end

    if carcass:isAnimalSkeleton() then
        ButcheringUtil.getAnimalBones(carcass, player);
        return;
    end

    -- parts (meat mainly)
    if carcass:getModData()["parts"] then
        local parts = ButcheringUtil.getAllPartsDef(ButcheringUtil.getCarcassName(carcass));
        for i,v in pairs(parts) do
            text = text .. ButcheringUtil.addAnimalPart(v, player, carcass, true);
        end
    end

    -- no leather when on ground! except for babies as they can't go on the hook
    -- leather
    if carcass:getModData()["babyLeather"] then
        local leather = ButcheringUtil.getLeather(carcass:getCarcassName());
        ---- TODO Leather quality maybe? (this gonna be screwed by the craftProcessor for now anyway)
        if leather then
            local leatherItem = player:getInventory():AddItem(leather);
            sendAddItemToContainer(player:getInventory(), leatherItem);
            text = text .. leatherItem:getDisplayName() .. "\r\n";
        end
    end

    -- head
    --if carcass:getModData()["animalRotStage"] == 0 then -- corpse is not rotten, otherwise we don't give a head (you'll get a skull from gathering bones)
        local head = ButcheringUtil.getHead(ButcheringUtil.getCarcassName(carcass));
        if head and carcass:getModData()["head"] then
            carcass:getModData()["head"] = nil;
            carcass:getModData()["headless"] = true;
            local headItem = instanceItem(head);
            if carcass:getModData()["animalRotStage"] > 0 then
                headItem:setAge(ZombRand(headItem:getOffAgeMax() + 3, headItem:getOffAgeMax() * 1.5));
            end
            local headItem = player:getInventory():AddItem(headItem);
            sendAddItemToContainer(player:getInventory(), headItem);
            text = text .. headItem:getDisplayName() .. "\r\n";
        end
    --end

    -- feather
    if breed:getFeatherItem() then
        local featherItems = player:getInventory():AddItems(breed:getFeatherItem(), carcass:getModData()["MaxFeather"]);
        if featherItems and not featherItems:isEmpty() then
            sendAddItemsToContainer(player:getInventory(), featherItems);
            text = text .. featherItems:size() .. " " .. featherItems:get(0):getDisplayName() .. "\r\n";
        end
    end

    text = text .. "\r\n";
    text = text .. "Total hunger: " .. round(totalHunger, 2) .. "\r\n";
    text = text .. "Total calories: " .. round(totalCalories, 2) .. "\r\n";
    text = text .. "Total proteins: " .. round(totalProteins, 2) .. "\r\n";
    text = text .. "Total lipids: " .. round(totalLipids, 2) .. "\r\n";
    text = text .. "Total carbo: " .. round(totalCarbo, 2) .. "\r\n";

    --print("text", text)

    --text = text .. "\r\n" .. leather:getDisplayName() .. "\r\n";

    -- in the butcher debug stuff i'm keeping the corpse to quickly test again
    if not keepCorpse and not partDef.noSkeleton then
        carcass:getModData()["skeleton"] = "true";
        carcass:getModData()["parts"] =  nil;
        carcass:changeRotStage(2 - carcass:getModData()["animalRotStage"]); -- switch to a bloody skeleton, if we were rotten we remove one stage, otherwise update will put it to stage 4
        carcass:invalidateCorpse();
    end

    if carcass:getSquare() then
        if partDef.noSkeleton then
            carcass:getSquare():removeCorpse(carcass, false);
            carcass:invalidateCorpse();
        else
            carcass:transmitModData();
        end
    end

    -- add possible blood on character
    local bloodNb = ZombRand(22 - (player:getPerkLevel(Perks.Butchering) * 2));

    -- if animal still had blood in it, add lots more
    local bloodGround = 0;
    if carcass:getModData()["BloodQty"] > 0 then
        bloodNb = bloodNb + carcass:getModData()["BloodQty"] * 2
        bloodGround = carcass:getModData()["BloodQty"] * 2;
    end

    -- add some blood on ground and on player
    for i=0,bloodNb do
        player:addBlood(nil, true, false, false);
    end
    syncVisuals(player);

    for i=0,bloodGround do
        addBloodSplat(carcass:getSquare(), 2, ZombRandFloat(-0.3, 0.3), ZombRandFloat(-0.3, 0.3))
    end

    return text;
end

function ButcheringUtil.getLeather(name)
    local def = ButcheringUtil.getAnimalDef(name);

    if def == nil then
        log(DebugType.Animal, "Couldn't find animal parts def for " .. name);
    end

    return def.leather;
end

function ButcheringUtil.getHead(name)
    local def = ButcheringUtil.getAnimalDef(name);

    if def == nil then
        log(DebugType.Animal, "Couldn't find animal parts def for " .. name);
    end

    return def.head;
end

function ButcheringUtil.getSkull(name)
    local def = ButcheringUtil.getAnimalDef(name);

    if def == nil then
        log(DebugType.Animal, "Couldn't find animal parts def for " .. name);
    end

    return def.skull;
end

-- Add an animal part in the player's inventory
-- If the part is a food we gonna modify it
function ButcheringUtil.addAnimalPart(part, player, carcass, fromGround)
    local skill = player:getPerkLevel(Perks.Butchering);
    local text = "";
    -- if you're doing it from ground but animal can't go on a hook, it's all ok
    if fromGround then
        if not AnimalAvatarDefinition[carcass:getModData()["AnimalType"]] or not AnimalAvatarDefinition[carcass:getModData()["AnimalType"]].hook then
            fromGround = false;
        end
    end

    -- if animal was pregnant add a dead baby on the ground, i'm sorry, i had to...
    if carcass:getModData()["wasPregnant"] and carcass:getModData()["pregnancyTime"] > 0.3 then
        local def = AnimalDefinitions.animals[carcass:getModData()["AnimalType"]];
        if def then
            for i=0, carcass:getModData()["babiesNbr"] - 1 do
                local baby = IsoAnimal.new(getCell(), carcass:getSquare():getX(), carcass:getSquare():getY(), carcass:getSquare():getZ(), def.babyType, carcass:getModData()["AnimalBreed"]);
                baby:getData():setSizeForced(carcass:getModData()["pregnancyTime"] / 2)
                local corpse = IsoDeadBody.new(baby, false);
                carcass:getSquare():addCorpse(corpse, false);
                corpse:invalidateCorpse();
                corpse:setInvalidateNextRender(true);
                baby:remove();

                sendCorpse(corpse);
            end
        end
        carcass:getModData()["wasPregnant"] = false;
        carcass:getModData()["pregnancyTime"] = 0;
        carcass:transmitModData();
    end

    --print("do animal part", part.item, part.minNb, part.maxNb)
    if not part.minNb then part.minNb = -1; end
    if not part.maxNb then part.maxNb = -1; end
    if not part.nb then part.nb = -1; end
    -- number of parts depend on size
    local minNb = part.minNb * carcass:getAnimalSize();
    local maxNb = part.maxNb * carcass:getAnimalSize();
    local nb = part.nb;
    -- lower parts gathered if from the ground
    if fromGround then
        minNb = minNb * 0.6;
        maxNb = maxNb * 0.6;
    else
        minNb = minNb * 1.2;
        maxNb = maxNb * 1.2;
    end

    -- every 2 pts in butchering gives * 1.1 max meat ratio
    local skillIndex = (math.floor(skill/2) / 10) + 1;
    maxNb = maxNb * skillIndex;


    local meatRatio = carcass:getModData()["meatRatio"];
    if meatRatio <= 0 then
        meatRatio = 1;
    end

    local item = instanceItem(part.item);
    if instanceof(item, "Food") then
        -- We add more or less meat depending on its meatRatio
        minNb = meatRatio * minNb;
        maxNb = meatRatio * maxNb;
    end

    --print("meat ratio", meatRatio, minNb, maxNb, nb, carcass:getAnimalSize())

    if carcass:getModData()["roadKill"] then
        minNb = minNb / 2;
        maxNb = maxNb / 2;
        meatRatio = ZombRandFloat(0.2, 0.4);
    end

    local rotten = false;
    -- depending on the time passed since death we lower the food nb/ratio
    local deathAge = carcass:getModData()["deathAge"] or 0;
    if deathAge > 12 then -- give 12h before starting to lower it
        local delta = deathAge/30;
        minNb = minNb / delta;
        maxNb = maxNb / delta;
        meatRatio = meatRatio / delta;
        if carcass:getModData()["animalRotStage"] > 0 then -- corpse has rotten
            rotten = true;
        end
    end

    if nb == -1 then
        nb = ZombRand(minNb, maxNb);
    end

    if nb < 1 then
        nb = 1;
    end

    -- meat can be modified to give prime cut/medium cut etc.
    if AnimalPartsDefinitions.meat[part.item] then
        text = text .. ButcheringUtil.giveMeatModified(AnimalPartsDefinitions.meat[part.item], nb, player, meatRatio, carcass, fromGround, rotten, deathAge);
        return text;
    end

    local animalDef = ButcheringUtil.getAnimalDef(ButcheringUtil.getCarcassName(carcass));
    for i=0,nb-1 do
        item = instanceItem(part.item);

        -- If the item is a food we alter its hunger depending on the size of animal
        if instanceof(item, "Food") then
            text = text .. ButcheringUtil.modifyMeat(item, carcass:getAnimalSize(), meatRatio, 1, rotten, deathAge);
        else
            text = text .. item:getDisplayName();
        end

        player:getInventory():AddItem(item);
        sendAddItemToContainer(player:getInventory(), item);
        addXp(player, Perks.Butchering, animalDef.xpPerItem)
    end

    return text;
end

function ButcheringUtil.getCarcassName(carcass)
    local carcassName = "";
    if instanceof(carcass, "IsoDeadBody") then
        carcassName = carcass:getCarcassName();
    end
    if instanceof(carcass, "IsoAnimal") then
        carcassName = carcass:getTypeAndBreed();
    end
    return carcassName;
end

-- lua doesn't have a round function :(
function roundButcher(x)
    --print("round ", x, x>=0 and math.floor(x+0.5) or math.ceil(x-0.5))
    return x>=0 and math.floor(x+0.5) or math.ceil(x-0.5)
end

-- gives various type of meat depending on the definition
function ButcheringUtil.giveMeatModified(meatDef, nb, player, meatRatio, carcass, fromGround, rotten, deathAge)
    local text = "";
    local percRest = 100;
    local animalDef = ButcheringUtil.getAnimalDef(ButcheringUtil.getCarcassName(carcass));
    local baseXp = animalDef.xpPerItem;
    --print("animal def?", carcass:getCarcassName(), animalDef)
    --print("total to give:", nb)
    for i,partDef in pairs(meatDef.variants) do
        -- give more xp for prime cut (top of the list)
        local nbInList = (#meatDef.variants + 1 - i) * 0.8;
        local xpToGive = baseXp * nbInList;

        local chance = ButcheringUtil.getPartChance(partDef.baseChance, carcass:getAnimalSize(), meatRatio, player);
        local nbToGive = roundButcher(nb * (chance / 100));
        nb = nb - nbToGive;
        percRest = percRest - chance;

        --print("item type: ", i, "item name", partDef.item, "chance:", chance, "giving:", nbToGive, "rest to give", nb, "percRest", percRest)

        for j=0,nbToGive-1 do
            local item = instanceItem(partDef.item);

            local hungChangePositive = round(math.abs(item:getHungChange() * 100), 2);

            local hungerText = " (hunger: " .. hungChangePositive .. " -> ";

            local hungerBoost = partDef.hungerBoost;
            if fromGround then
                hungerBoost = hungerBoost * 0.6;
            end
            ButcheringUtil.modifyMeat(item, carcass:getAnimalSize(), meatRatio, hungerBoost, rotten, deathAge);
            item:setName(getText("IGUI_AnimalMeat", getText(partDef.baseName), getText(partDef.extraName)))
            item:setCustomName(true);

            hungChangePositive = round(math.abs(item:getHungChange() * 100), 2);

            if hungChangePositive > 0 then
                text = text .. item:getDisplayName() .. hungerText .. hungChangePositive .. ")" .. "\r\n";
            else
                text = text .. item:getDisplayName() .. "\r\n";
            end

            player:getInventory():AddItem(item);
            sendAddItemToContainer(player:getInventory(), item);
            addXp(player, Perks.Butchering, xpToGive)
        end

        if nb <= 0 then return text; end
    end

    return text;
end

function ButcheringUtil.getPartChance(baseChance, size, meatRatio, player)
    local skill = player:getPerkLevel(Perks.Butchering);
    local skillMod = (skill / 70) * 10;
    if not baseChance then return 100; end -- the last item don't have a baseChance as we want to give everything that can still be given
    --print("get part chance", "base chance:", baseChance, "size:", size, "meatRatio:", meatRatio, "result:", baseChance * size * meatRatio)
    return baseChance * size * meatRatio * skillMod;
end

-- Modify the meat/food item given by the butchering by the meatRatio & size of animal
-- Adding a *0.9-1.1 for extra flavor
function ButcheringUtil.modifyMeat(item, size, meatRatio, hungerBoost, rotten, deathAge)
    local text = "";

    local ratio = size * meatRatio;
    if hungerBoost then
        ratio = ratio * hungerBoost;
    end

    local hungChangePositive = round(math.abs(item:getHungChange() * 100), 2);

    local hungerText = " (hunger: " .. hungChangePositive .. " -> ";

    item:setHungChange(item:getBaseHunger() * ratio * ZombRandFloat(0.9, 1.1));
    item:setBaseHunger(item:getHungerChange());
    item:setCalories(item:getCalories() * ratio * ZombRandFloat(0.9, 1.1));
    item:setLipids(item:getLipids() * ratio * ZombRandFloat(0.9, 1.1));
    item:setProteins(item:getProteins() * ratio * ZombRandFloat(0.9, 1.1));
    item:setCarbohydrates(item:getCarbohydrates() * ratio * ZombRandFloat(0.9, 1.1));

    if rotten then
        item:setAge(ZombRand(item:getOffAgeMax() + 3, item:getOffAgeMax() * 1.5));
    else
        item:setAge(ZombRand(0, deathAge/10));
    end

    hungChangePositive = round(math.abs(item:getHungChange() * 100), 2);

    if hungChangePositive > 0 then
        text = text .. item:getDisplayName() .. hungerText .. hungChangePositive .. ")" .. "\r\n";
    else
        text = text .. item:getDisplayName() .. "\r\n";
    end

    if totalHunger then
        totalHunger = totalHunger + hungChangePositive;
        totalCalories = totalCalories + item:getCalories();
        totalLipids = totalLipids + item:getLipids();
        totalCarbo = totalCarbo + item:getCarbohydrates();
        totalProteins = totalProteins + item:getProteins();
    end

    return text;
end

function ButcheringUtil.getAnimalBones(carcass, player)
    local parts = ButcheringUtil.getAllBonesDef(ButcheringUtil.getCarcassName(carcass));
    for i,v in pairs(parts) do
        ButcheringUtil.addAnimalPart(v, player, carcass);
    end

    if not carcass:getModData()["headless"] then -- we might still have a skull to get
        local skull = ButcheringUtil.getSkull(ButcheringUtil.getCarcassName(carcass));
        if skull then
            carcass:getModData()["head"] = nil;
            carcass:getModData()["headless"] = true;
            carcass:transmitModData();
            local skullItem = player:getInventory():AddItem(skull);
            sendAddItemToContainer(player:getInventory(), skullItem);
        end
    end

    player:getInventory():setDrawDirty(true);

    if not isServer() then
        local pdata = getPlayerData(player:getPlayerNum());
        if pdata ~= nil then
            pdata.playerInventory:refreshBackpacks();
            pdata.lootInventory:refreshBackpacks();
        end
    end

    carcass:getSquare():removeCorpse(carcass, false);
    --carcass:invalidateCorpse();

    --sq:RecalcProperties();
end

function ButcheringUtil.getAllBonesDef(name)
    local def = ButcheringUtil.getAnimalDef(name);

    print("want bones for ", name, def, def.bones)

    if def == nil then
        log(DebugType.Animal, "Couldn't find animal parts def for " .. name);
    end

    return def.bones;
end

function ButcheringUtil.getAllPartsDef(name)
    local def = ButcheringUtil.getAnimalDef(name);

    if def == nil then
        log(DebugType.Animal, "Couldn't find animal parts def for " .. name);
    end

    return def.parts;
end

function ButcheringUtil.getAnimalDef(name)
    for i,v in pairs(AnimalPartsDefinitions.animals) do
        if i == name then
            return v;
        end
    end
end

function ButcheringUtil.onAddedCorpseOnHook(hook, corpse, character)
    local wasDeadBody = instanceof(corpse, "IsoDeadBody");
    local newCorpse = ButcheringUtil.createCorpseFromItem(corpse, character); -- used to get the skin texture

    ButcheringUtil.createAnimalForHook(hook, newCorpse);

    if wasDeadBody and corpse then
        corpse:getSquare():removeCorpse(corpse, false);
        corpse:invalidateCorpse();
    end
    if not wasDeadBody and corpse:getContainer() then
        local inv = corpse:getContainer()
        inv:Remove(corpse);
        inv:setDrawDirty(true);
        sendRemoveItemFromContainer(inv, corpse);
    end

    return newCorpse;
end

function ButcheringUtil.createCorpseFromItem(item, chr)
    if instanceof(item, "IsoDeadBody") or instanceof(item, "IsoAnimal") then
        return item;
    end

    return chr:getCurrentSquare():createAnimalCorpseFromItem(item);
end

function ButcheringUtil.createAnimalForHook(hook, newCorpse)
    local modData = newCorpse:getModData();
    local animal = IsoAnimal.new(getCell(), hook:getSquare():getX(), hook:getSquare():getY(), hook:getSquare():getZ(), modData["AnimalType"], modData["AnimalBreed"]);
    if newCorpse then
        modData["originalSize"] = newCorpse:getAnimalSize();
    end
    animal:getData():setSizeForced(AnimalAvatarDefinition[modData["AnimalType"]].animalPositionSize)
    if modData["animalSize"] < animal:getData():getSize() then
        animal:getData():setSizeForced(modData["animalSize"]);
    end
    hook:setAnimal(animal);
    animal:setDir(IsoDirections.NE)
    animal:setX(animal:getX() + AnimalAvatarDefinition[modData["AnimalType"]].animalPositionX)
    animal:setY(animal:getY() + AnimalAvatarDefinition[modData["AnimalType"]].animalPositionY)
    animal:setZ(animal:getZ() + AnimalAvatarDefinition[modData["AnimalType"]].animalPositionZ)
    animal:setOnHook(true);
    animal:setHook(hook);
    animal:setModData(modData)
    animal:getAnimalVisual():setSkinTextureName(newCorpse:getAnimalVisual():getSkinTexture());
    animal:transmitModData();
end

function ButcheringUtil.onRemoveCorpseFromHook(hook, animal)
    animal:getData():setSizeForced(animal:getModData()["originalSize"])

    local body
    if not isClient() then
        body = IsoDeadBody.new(animal, false);
        body:setX(animal:getX());
        body:setY(animal:getY());
        body:setZ(hook:getZ());

        if animal:getModData()["skeleton"] == "true" then
            body:changeRotStage(2); -- switch to a bloody skeleton
        end

        body:invalidateCorpse();
        body:setInvalidateNextRender(true);
        body:setModData(animal:getModData())
    end

    hook:playPutDownCorpseSound(animal);
    hook:setAnimal(nil);

    if animal then
        animal:remove();
    end

    if isServer() then
        hook:sync();
        removeAnimal(animal:getOnlineID());
        sendCorpse(body);
    end

    return body;
end

function ButcheringUtil.updateCorpseDatas(dataTable, animal, hook)
    dataTable.leather = nil;
    dataTable.blood = 0;
    dataTable.head = nil;
    dataTable.meat = nil;

    if not animal or not ButcheringUtil.getAnimalDef(animal:getTypeAndBreed()) then
        return false;
    end

    local modData = animal:getModData();

    dataTable.leather = modData["leather"];
    dataTable.blood = tonumber(modData["BloodQty"]);
    dataTable.head = not modData["headless"];
    dataTable.meat = modData["parts"];

    local partDef = ButcheringUtil.getAnimalDef(animal:getTypeAndBreed());
    local noSkeleton = false;
    if partDef and partDef.noSkeleton then
        noSkeleton = true;
    end

    if not dataTable.leather and not dataTable.head and not dataTable.meat and (not dataTable.blood or dataTable.blood <= 0) then
        if noSkeleton then
            --if not self.animal3D then
            --    return;
            --end
            --if self.corpse:getSquare() then
            --    self.corpse:getSquare():removeCorpse(self.corpse);
            --end
            --local body = IsoDeadBody.new(self.animal3D, false);
            --body:setX(self.animal3D:getX());
            --body:setY(self.animal3D:getY());
            --body:setZ(self.hook:getZ());
            --if self.animal3D then
            --    self.animal3D:remove();
            --end
            --self.corpse = nil;
            --self.hook:setCorpse(nil);
            --self.hook:setAnimal(nil);
            --self:setAnimalAvatar();
        else
            animal:getModData()["skeleton"] = "true";

            if isServer() then
                animal:transmitModData();
            end
            --self.corpse:invalidateCorpse();
            --self:onClickRemoveCorpse();
        end

        if isServer() then
            ButcheringUtil.onRemoveCorpseFromHook(hook, animal);
        else
            dataTable:onClickRemoveCorpse();
        end
    end

    return true;
end

function ButcheringUtil.getBuckets(character)
    return character:getInventory():getAvailableFluidContainer("AnimalBlood");
end

function ButcheringUtil.isHookUsingSameCharacter(hook, character)
    if not hook:getUsingPlayer() then
        return true;
    end

    return hook:getUsingPlayer() == character;
end

function ButcheringUtil.setUsingPlayerForHook(hook, character)
    if isServer() then
        hook:setUsingPlayer(character);
        hook:sync()
    end
end